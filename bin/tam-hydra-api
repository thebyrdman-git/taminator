#!/usr/bin/env python3

"""
TAM RFE Hydra API - Phase 2
Direct Hydra API access using rhcase authentication for organizational discovery
"""

import json
import sys
import subprocess
from pathlib import Path
from typing import Optional, Dict, List, Any
import urllib.request
import urllib.error
import urllib.parse

class HydraAPI:
    """Direct Hydra API client using rhcase authentication"""
    
    def __init__(self):
        self.base_url = "https://access.redhat.com/hydra/rest"
        self.rhcase_path = self._find_rhcase()
        
    def _find_rhcase(self) -> str:
        """Find rhcase executable"""
        # Try local rhcase first
        script_dir = Path(__file__).parent
        project_root = script_dir.parent
        local_rhcase = project_root / "rhcase" / ".venv" / "bin" / "rhcase"
        
        if local_rhcase.exists():
            return str(local_rhcase)
        
        # Fall back to system rhcase
        return "rhcase"
    
    def _make_authenticated_request(self, endpoint: str, params: Optional[Dict] = None) -> Optional[Any]:
        """
        Make authenticated request to Hydra API using rhcase's auth system
        
        Strategy: Use rhcase as a subprocess to handle authentication,
        then extract the response data
        """
        url = f"{self.base_url}{endpoint}"
        
        if params:
            query = urllib.parse.urlencode(params)
            url = f"{url}?{query}"
        
        try:
            # Use rhcase's authentication by making it do the request
            # rhcase handles OAuth2 token management internally
            
            # For now, we'll use curl with Basic Auth as fallback
            # This works for case data but org APIs may need different auth
            
            cmd = [
                "curl", "-s",
                "--negotiate", "-u", ":",
                url
            ]
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0 and result.stdout:
                try:
                    return json.loads(result.stdout)
                except json.JSONDecodeError:
                    print(f"âš ï¸  Invalid JSON response", file=sys.stderr)
                    return None
            else:
                print(f"âŒ Request failed: {result.stderr}", file=sys.stderr)
                return None
                
        except subprocess.TimeoutExpired:
            print("âŒ Request timed out", file=sys.stderr)
            return None
        except Exception as e:
            print(f"âŒ Request error: {e}", file=sys.stderr)
            return None
    
    def get_accounts_by_org(self, org_name: str) -> List[Dict]:
        """
        Get all accounts in an organization
        
        Note: This endpoint may not exist in current Hydra API.
        This is the INTENDED interface for Phase 2.
        """
        print(f"ğŸ” Querying organization: {org_name}", file=sys.stderr)
        
        # Try organizational endpoint (may not exist)
        endpoint = f"/organizations/{org_name}/accounts"
        result = self._make_authenticated_request(endpoint)
        
        if result:
            return result if isinstance(result, list) else result.get('accounts', [])
        
        # Fallback: Use case-based discovery with filtering
        print("â„¹ï¸  Organization endpoint not available, using case-based discovery", file=sys.stderr)
        return self._discover_via_cases_with_org_filter(org_name)
    
    def _discover_via_cases_with_org_filter(self, org_name: str) -> List[Dict]:
        """
        Discover accounts via case data with organizational heuristics
        
        For NAPS: Look for government/public sector indicators
        For Commercial: Look for non-public sector
        """
        # Get all accounts from case system
        cmd = [self.rhcase_path, "list", "--all", "--months", "6", "--format", "json"]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            if result.returncode == 0:
                cases = json.loads(result.stdout)
                
                # Apply organizational heuristics
                accounts = {}
                org_lower = org_name.lower()
                
                for case in cases:
                    acct_num = case.get('accountNumber')
                    if not acct_num or acct_num in accounts:
                        continue
                    
                    acct = case.get('account', {})
                    acct_name = acct.get('name', '').lower()
                    vertical = acct.get('vertical', '').lower()
                    
                    # NAPS heuristics (government/public sector)
                    is_naps = any([
                        'government' in acct_name,
                        'federal' in acct_name,
                        'state' in acct_name,
                        'county' in acct_name,
                        'city' in acct_name,
                        'public' in vertical,
                        'gov' in acct_name
                    ])
                    
                    # Match organization filter
                    if org_lower == 'naps' and is_naps:
                        accounts[acct_num] = {
                            'accountNumber': acct_num,
                            'name': acct.get('name'),
                            'vertical': acct.get('vertical'),
                            'organization': 'NAPS (inferred)',
                            'csmUser': acct.get('csmUser', {}).get('name')
                        }
                    elif org_lower == 'commercial' and not is_naps:
                        accounts[acct_num] = {
                            'accountNumber': acct_num,
                            'name': acct.get('name'),
                            'vertical': acct.get('vertical'),
                            'organization': 'Commercial (inferred)',
                            'csmUser': acct.get('csmUser', {}).get('name')
                        }
                
                return list(accounts.values())
        except Exception as e:
            print(f"âŒ Error discovering via cases: {e}", file=sys.stderr)
        
        return []
    
    def get_my_assignments(self) -> List[Dict]:
        """
        Get all customer assignments for the current TAM
        
        Note: TAM assignment endpoint may not be available.
        This is the INTENDED interface for Phase 2.
        """
        print("ğŸ” Fetching your TAM assignments", file=sys.stderr)
        
        # Try TAM assignment endpoint (may not exist)
        endpoint = "/tam/assignments"
        result = self._make_authenticated_request(endpoint)
        
        if result:
            return result if isinstance(result, list) else result.get('assignments', [])
        
        # Fallback: Get configured accounts
        print("â„¹ï¸  TAM assignment endpoint not available, using configured accounts", file=sys.stderr)
        return self._get_configured_accounts()
    
    def _get_configured_accounts(self) -> List[Dict]:
        """Get accounts from tamscripts.config as fallback"""
        config_file = Path.home() / ".config" / "tamscripts" / "tamscripts.config"
        
        if not config_file.exists():
            return []
        
        # Parse YAML to get configured accounts
        cmd = [self.rhcase_path, "list", "--all", "--months", "1", "--format", "json"]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            if result.returncode == 0:
                cases = json.loads(result.stdout)
                
                # Extract unique accounts
                accounts = {}
                for case in cases:
                    acct_num = case.get('accountNumber')
                    if acct_num and acct_num not in accounts:
                        acct = case.get('account', {})
                        accounts[acct_num] = {
                            'accountNumber': acct_num,
                            'name': acct.get('name'),
                            'vertical': acct.get('vertical'),
                            'csmUser': acct.get('csmUser', {}).get('name'),
                            'assignment': 'configured'
                        }
                
                return list(accounts.values())
        except Exception:
            pass
        
        return []
    
    def search_accounts(self, search_term: str, limit: int = 10) -> List[Dict]:
        """Search for accounts by name"""
        print(f"ğŸ” Searching for: {search_term}", file=sys.stderr)
        
        cmd = [self.rhcase_path, "list", "--all", "--months", "6", "--format", "json"]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            if result.returncode == 0:
                cases = json.loads(result.stdout)
                
                # Search and deduplicate
                accounts = {}
                search_lower = search_term.lower()
                
                for case in cases:
                    acct = case.get('account', {})
                    acct_name = acct.get('name', '').lower()
                    acct_num = case.get('accountNumber')
                    
                    if search_lower in acct_name and acct_num not in accounts:
                        accounts[acct_num] = {
                            'accountNumber': acct_num,
                            'name': acct.get('name'),
                            'vertical': acct.get('vertical'),
                            'csmUser': acct.get('csmUser', {}).get('name')
                        }
                        
                        if len(accounts) >= limit:
                            break
                
                return list(accounts.values())
        except Exception as e:
            print(f"âŒ Search error: {e}", file=sys.stderr)
        
        return []

def format_account(account: Dict) -> str:
    """Format account for display"""
    lines = []
    lines.append("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
    lines.append(f"ğŸ¢ Customer: {account.get('name', 'Unknown')}")
    lines.append(f"   Account #: {account.get('accountNumber', 'Unknown')}")
    
    if 'organization' in account:
        lines.append(f"   Organization: {account['organization']}")
    if 'vertical' in account:
        lines.append(f"   Vertical: {account['vertical']}")
    if 'csmUser' in account:
        lines.append(f"   CSM: {account['csmUser']}")
    if 'assignment' in account:
        lines.append(f"   Assignment: {account['assignment']}")
    
    lines.append("")
    return "\n".join(lines)

def main():
    import argparse
    
    parser = argparse.ArgumentParser(
        description='Hydra API Phase 2 - Direct organizational discovery',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s org NAPS                  # Get NAPS organization customers
  %(prog)s org Commercial            # Get Commercial customers
  %(prog)s my-assignments            # Get your TAM assignments
  %(prog)s search "Acme Corp"        # Search for customer

Note: 
- Phase 2 uses case-based discovery with organizational heuristics
- True org endpoints require Hydra API organizational access
- Requires Red Hat VPN connection
        """
    )
    
    parser.add_argument('command', choices=[
        'org', 'my-assignments', 'search', 'test'
    ], help='Command to execute')
    
    parser.add_argument('argument', nargs='?', help='Command argument')
    
    args = parser.parse_args()
    
    api = HydraAPI()
    
    if args.command == 'test':
        print("ğŸ” Testing Hydra API Phase 2...")
        print(f"   Base URL: {api.base_url}")
        print(f"   rhcase: {api.rhcase_path}")
        print("\nâœ… Phase 2 API client initialized")
        print("\nâ„¹ï¸  Note: Using case-based discovery with organizational heuristics")
        print("   True org endpoints require direct Hydra API access")
        return
    
    # Execute commands
    accounts = []
    
    if args.command == 'org':
        if not args.argument:
            print("âŒ Error: Organization name required", file=sys.stderr)
            print("Example: tam-rfe-hydra-api org NAPS", file=sys.stderr)
            sys.exit(1)
        accounts = api.get_accounts_by_org(args.argument)
        
    elif args.command == 'my-assignments':
        accounts = api.get_my_assignments()
        
    elif args.command == 'search':
        if not args.argument:
            print("âŒ Error: Search term required", file=sys.stderr)
            print("Example: tam-rfe-hydra-api search 'Acme'", file=sys.stderr)
            sys.exit(1)
        accounts = api.search_accounts(args.argument)
    
    # Display results
    if accounts:
        print(f"\nâœ… Found {len(accounts)} account(s):\n")
        for account in accounts:
            print(format_account(account))
        
        print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
        print("\nğŸ’¡ To add any customer to your automation:")
        print("   ./bin/tam-rfe-onboard-intelligent\n")
    else:
        print("âš ï¸  No accounts found")

if __name__ == '__main__':
    main()

