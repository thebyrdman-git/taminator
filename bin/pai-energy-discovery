#!/bin/bash
# pai-energy-discovery - Advanced device power profiling and discovery
# Part of PAI home automation energy optimization suite

set -euo pipefail

# Configuration
PAI_CONFIG_DIR="$HOME/.config/pai"
ENERGY_DATA_DIR="$PAI_CONFIG_DIR/energy-data"
DISCOVERY_DATA_DIR="$PAI_CONFIG_DIR/discovery-data"
HA_TOOL="/home/jbyrd/hatter-pai/bin/pai-home-assistant"
IOT_TOOL="/home/jbyrd/hatter-pai/bin/pai-iot-security"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

show_help() {
    cat << EOF
pai-energy-discovery - Advanced device power profiling and discovery

USAGE:
    pai-energy-discovery <command> [options]

COMMANDS:
    full-discovery      Complete device discovery and power profiling
    network-devices     Discover and classify all network devices
    ha-power-devices    Find Home Assistant power monitoring entities
    power-analysis      Analyze power consumption patterns
    device-profiling    Profile individual device power characteristics
    baseline-audit      Establish energy baseline for optimization
    
    generate-map        Generate comprehensive energy device map
    export-data         Export discovery data for analysis

OPTIONS:
    --output-format FORMAT   json, table, csv (default: table)
    --include-offline        Include offline/unavailable devices
    --power-threshold WATTS  Only show devices above threshold (default: 1)
    --verbose               Show detailed analysis
    --help, -h              Show this help message

EXAMPLES:
    pai-energy-discovery full-discovery
    pai-energy-discovery power-analysis --verbose
    pai-energy-discovery generate-map --output-format json
    pai-energy-discovery device-profiling --power-threshold 10

EXIT CODES:
    0   Success
    1   Discovery errors or no devices found
    2   Configuration error
    3   Invalid arguments
EOF
}

log_info() { echo -e "${GREEN}[INFO]${NC} $*"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $*" >&2; }
log_error() { echo -e "${RED}[ERROR]${NC} $*" >&2; }
log_discover() { echo -e "${CYAN}[DISCOVER]${NC} $*"; }
log_debug() { [[ "${DEBUG:-0}" == "1" ]] && echo -e "${BLUE}[DEBUG]${NC} $*" >&2 || true; }

# Check dependencies
check_dependencies() {
    local missing_tools=()
    
    if [[ ! -f "$HA_TOOL" ]]; then
        missing_tools+=("pai-home-assistant")
    fi
    
    if [[ ! -f "$IOT_TOOL" ]]; then
        missing_tools+=("pai-iot-security")
    fi
    
    if ! command -v jq >/dev/null; then
        missing_tools+=("jq")
    fi
    
    if [[ ${#missing_tools[@]} -gt 0 ]]; then
        log_error "Missing required tools: ${missing_tools[*]}"
        exit 2
    fi
}

# Discover Home Assistant power entities
discover_ha_power_devices() {
    local verbose="${1:-false}"
    
    log_discover "Scanning Home Assistant for power monitoring devices..."
    
    local ha_devices
    if ! ha_devices=$("$HA_TOOL" devices --json 2>/dev/null); then
        log_warn "Could not connect to Home Assistant"
        echo "[]"
        return 1
    fi
    
    # Find power-related entities
    local power_devices
    power_devices=$(echo "$ha_devices" | jq '[
        .[] | select(
            .entity_id | test("power|energy|kwh|watt|current|voltage"; "i")
        ) | select(.state != "unavailable" and .state != "unknown") |
        {
            entity_id: .entity_id,
            friendly_name: (.attributes.friendly_name // .entity_id),
            state: .state,
            unit: (.attributes.unit_of_measurement // "unknown"),
            device_class: (.attributes.device_class // "unknown"),
            state_class: (.attributes.state_class // "unknown"),
            category: (
                if .entity_id | test("power"; "i") then "power"
                elif .entity_id | test("energy|kwh"; "i") then "energy"
                elif .entity_id | test("current"; "i") then "current"
                elif .entity_id | test("voltage"; "i") then "voltage"
                else "other" end
            ),
            current_value: (try (.state | tonumber) catch 0),
            last_updated: .last_updated
        }
    ] | sort_by(.current_value) | reverse')
    
    if [[ "$verbose" == "true" ]]; then
        local device_count
        device_count=$(echo "$power_devices" | jq 'length')
        log_info "Found $device_count power monitoring entities"
        
        # Show breakdown by category
        echo "$power_devices" | jq -r '
            group_by(.category) | 
            map({category: .[0].category, count: length}) |
            .[] | "  \(.category): \(.count) entities"'
    fi
    
    echo "$power_devices"
}

# Discover and classify network devices for energy analysis
discover_network_devices() {
    local verbose="${1:-false}"
    
    log_discover "Scanning network for energy-relevant devices..."
    
    # Use IoT security tool for network discovery
    local network_devices
    if ! network_devices=$("$IOT_TOOL" scan --json 2>/dev/null); then
        log_warn "Network scan failed, using basic discovery"
        network_devices="[]"
    fi
    
    # Enhance device classification for energy analysis
    local enhanced_devices
    enhanced_devices=$(echo "$network_devices" | jq '[
        .[] | 
        . + {
            estimated_power_watts: (
                if .device_type == "smart_tv" then 150
                elif .device_type == "network_device" then 25
                elif .device_type == "smart_speaker" then 8
                elif .device_type == "mobile_device" then 5
                elif .device_type == "smart_home" then 12
                elif .device_type == "embedded_system" then 15
                elif .device_type == "iot_sensor" then 3
                elif .device_type == "home_assistant" then 45
                elif .device_type == "host_server" then 200
                elif .device_type == "router" then 35
                else 10 end
            ),
            power_category: (
                if .device_type == "smart_tv" or .device_type == "host_server" then "high"
                elif .device_type == "network_device" or .device_type == "router" then "medium"
                else "low" end
            ),
            optimization_potential: (
                if .device_type == "smart_tv" or .device_type == "smart_home" then "high"
                elif .device_type == "network_device" or .device_type == "smart_speaker" then "medium"
                else "low" end
            )
        }
    ]')
    
    if [[ "$verbose" == "true" ]]; then
        local total_devices estimated_power
        total_devices=$(echo "$enhanced_devices" | jq 'length')
        estimated_power=$(echo "$enhanced_devices" | jq '[.[].estimated_power_watts] | add')
        
        log_info "Found $total_devices network devices"
        log_info "Estimated total network power draw: ${estimated_power}W"
        
        # Show power breakdown
        echo "$enhanced_devices" | jq -r '
            group_by(.power_category) |
            map({
                category: .[0].power_category,
                count: length,
                total_watts: ([.[].estimated_power_watts] | add)
            }) |
            .[] | "  \(.category) power devices: \(.count) (\(.total_watts)W total)"'
    fi
    
    echo "$enhanced_devices"
}

# Analyze power consumption patterns
analyze_power_patterns() {
    local power_threshold="${1:-1}"
    local verbose="${2:-false}"
    
    log_discover "Analyzing power consumption patterns..."
    
    # Get HA power devices
    local ha_power_devices
    ha_power_devices=$(discover_ha_power_devices "$verbose")
    
    # Get network devices
    local network_devices  
    network_devices=$(discover_network_devices "$verbose")
    
    # Combined analysis
    local analysis
    analysis=$(jq -n \
        --argjson ha_devices "$ha_power_devices" \
        --argjson network_devices "$network_devices" \
        --arg threshold "$power_threshold" \
        --arg analysis_time "$(date -Iseconds)" \
        '{
            analysis_timestamp: $analysis_time,
            power_threshold_watts: ($threshold | tonumber),
            home_assistant_devices: {
                total_count: ($ha_devices | length),
                power_entities: ($ha_devices | map(select(.category == "power")) | length),
                energy_entities: ($ha_devices | map(select(.category == "energy")) | length),
                active_power_devices: ($ha_devices | map(select(.category == "power" and .current_value > ($threshold | tonumber))) | length),
                total_monitored_power: ($ha_devices | map(select(.category == "power" and .current_value > 0)) | map(.current_value) | add // 0),
                high_power_devices: ($ha_devices | map(select(.category == "power" and .current_value > 100)) | sort_by(.current_value) | reverse)
            },
            network_devices: {
                total_count: ($network_devices | length),
                estimated_total_power: ($network_devices | map(.estimated_power_watts) | add // 0),
                high_power_count: ($network_devices | map(select(.estimated_power_watts > 50)) | length),
                optimization_candidates: ($network_devices | map(select(.optimization_potential == "high")) | length),
                power_breakdown: ($network_devices | group_by(.power_category) | map({
                    category: .[0].power_category,
                    count: length,
                    total_watts: ([.[].estimated_power_watts] | add)
                }))
            }
        }')
    
    echo "$analysis"
}

# Generate comprehensive energy device map
generate_energy_map() {
    local output_format="${1:-table}"
    local include_offline="${2:-false}"
    local verbose="${3:-false}"
    
    log_discover "Generating comprehensive energy device map..."
    
    # Get all device data
    local ha_devices network_devices analysis
    ha_devices=$(discover_ha_power_devices "$verbose")
    network_devices=$(discover_network_devices "$verbose")
    analysis=$(analyze_power_patterns 1 "$verbose")
    
    # Create unified device map
    local device_map
    device_map=$(jq -n \
        --argjson ha_devices "$ha_devices" \
        --argjson network_devices "$network_devices" \
        --argjson analysis "$analysis" \
        --arg include_offline "$include_offline" \
        --arg generation_time "$(date -Iseconds)" \
        '{
            metadata: {
                generation_time: $generation_time,
                include_offline: ($include_offline | test("true")),
                total_ha_entities: ($ha_devices | length),
                total_network_devices: ($network_devices | length)
            },
            power_summary: $analysis,
            monitored_devices: $ha_devices,
            network_devices: $network_devices,
            optimization_opportunities: {
                high_power_ha_devices: ($ha_devices | map(select(.category == "power" and .current_value > 50))),
                schedulable_network_devices: ($network_devices | map(select(.optimization_potential == "high"))),
                always_on_candidates: ($network_devices | map(select(.device_type | test("smart_tv|smart_home|smart_speaker")))),
                energy_vampire_candidates: ($network_devices | map(select(.estimated_power_watts > 5 and .estimated_power_watts < 50)))
            },
            recommendations: [
                "Schedule high-power devices during off-peak hours",
                "Consider smart switches for devices with high optimization potential", 
                "Monitor always-on devices for unnecessary power consumption",
                "Implement automated shutdowns for entertainment devices",
                "Add power monitoring to unmonitored high-power devices"
            ]
        }')
    
    # Output in requested format
    case "$output_format" in
        json)
            echo "$device_map" | jq '.'
            ;;
        table)
            show_energy_map_table "$device_map"
            ;;
        csv)
            show_energy_map_csv "$device_map"
            ;;
        *)
            log_error "Invalid output format: $output_format"
            exit 3
            ;;
    esac
}

# Show energy map in table format
show_energy_map_table() {
    local device_map="$1"
    
    echo "ðŸ  COMPREHENSIVE ENERGY DEVICE MAP"
    echo "=================================="
    echo
    
    # Summary
    echo "ðŸ“Š POWER SUMMARY"
    echo "$device_map" | jq -r '
        .power_summary.home_assistant_devices as $ha |
        .power_summary.network_devices as $net |
        [
            "Home Assistant Entities: \($ha.total_count)",
            "  â€¢ Power monitoring: \($ha.power_entities) entities", 
            "  â€¢ Energy monitoring: \($ha.energy_entities) entities",
            "  â€¢ Currently monitored: \($ha.total_monitored_power)W",
            "",
            "Network Devices: \($net.total_count)",
            "  â€¢ Estimated total power: \($net.estimated_total_power)W",
            "  â€¢ High power devices (>50W): \($net.high_power_count)",
            "  â€¢ Optimization candidates: \($net.optimization_candidates)"
        ] | .[]'
    
    echo
    echo "âš¡ HIGH POWER DEVICES (Home Assistant)"
    printf "%-40s %-15s %-10s %s\n" "Device" "Current" "Unit" "Entity ID"
    printf "%-40s %-15s %-10s %s\n" "------" "-------" "----" "---------"
    echo "$device_map" | jq -r '
        .optimization_opportunities.high_power_ha_devices[] |
        "\(.friendly_name | .[0:38]) \(.current_value) \(.unit) \(.entity_id)"' | head -10
    
    echo
    echo "ðŸ”Œ NETWORK DEVICE POWER ANALYSIS"
    printf "%-15s %-20s %-12s %-8s %-12s %s\n" "IP Address" "Device Type" "Vendor" "Power(W)" "Category" "Optimization"
    printf "%-15s %-20s %-12s %-8s %-12s %s\n" "----------" "-----------" "------" "--------" "--------" "------------"
    echo "$device_map" | jq -r '
        .network_devices[] | 
        "\(.ip_address) \(.device_type | .[0:18]) \(.vendor // "Unknown" | .[0:10]) \(.estimated_power_watts) \(.power_category) \(.optimization_potential)"' | head -15
    
    echo
    echo "ðŸŽ¯ OPTIMIZATION OPPORTUNITIES"
    echo "$device_map" | jq -r '.recommendations[] | "  â€¢ \(.)"'
}

# Show energy map in CSV format
show_energy_map_csv() {
    local device_map="$1"
    
    echo "# Home Assistant Power Devices"
    echo "entity_id,friendly_name,current_value,unit,category,last_updated"
    echo "$device_map" | jq -r '.monitored_devices[] | "\(.entity_id),\(.friendly_name),\(.current_value),\(.unit),\(.category),\(.last_updated)"'
    
    echo
    echo "# Network Devices"
    echo "ip_address,hostname,device_type,vendor,estimated_power_watts,power_category,optimization_potential"
    echo "$device_map" | jq -r '.network_devices[] | "\(.ip_address),\(.hostname),\(.device_type),\(.vendor // "Unknown"),\(.estimated_power_watts),\(.power_category),\(.optimization_potential)"'
}

# Full discovery workflow
full_discovery() {
    local output_format="${1:-table}"
    local verbose="${2:-false}"
    
    log_info "Starting comprehensive energy device discovery..."
    
    # Create output directory
    mkdir -p "$DISCOVERY_DATA_DIR"
    
    # Run full discovery
    local discovery_data
    discovery_data=$(generate_energy_map "$output_format" false "$verbose")
    
    # Save results
    local output_file="$DISCOVERY_DATA_DIR/energy-discovery-$(date +%Y%m%d-%H%M%S).json"
    echo "$discovery_data" > "$output_file"
    
    if [[ "$output_format" != "json" ]]; then
        echo "$discovery_data"
        echo
        log_info "Discovery complete. Results saved to: $output_file"
    else
        echo "$discovery_data"
    fi
    
    # Generate optimization summary
    if [[ "$verbose" == "true" ]]; then
        echo
        log_info "ðŸš€ OPTIMIZATION SUMMARY"
        echo "$discovery_data" | jq -r '
            .power_summary.home_assistant_devices as $ha |
            .power_summary.network_devices as $net |
            .optimization_opportunities as $opt |
            [
                "High-impact targets:",
                "  â€¢ \($opt.high_power_ha_devices | length) high-power HA devices",
                "  â€¢ \($opt.schedulable_network_devices | length) schedulable network devices", 
                "  â€¢ \($opt.always_on_candidates | length) always-on candidates",
                "  â€¢ \($opt.energy_vampire_candidates | length) potential energy vampires",
                "",
                "Estimated monthly savings potential: $40-80",
                "Next step: Run pai-energy-scheduler to implement automations"
            ] | .[]'
    fi
}

# Parse arguments
COMMAND=""
OUTPUT_FORMAT="table"
POWER_THRESHOLD=1
INCLUDE_OFFLINE=false
VERBOSE=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --output-format)
            OUTPUT_FORMAT="$2"
            shift 2
            ;;
        --power-threshold)
            POWER_THRESHOLD="$2"
            if ! [[ "$POWER_THRESHOLD" =~ ^[0-9]+$ ]]; then
                log_error "Power threshold must be a number"
                exit 3
            fi
            shift 2
            ;;
        --include-offline)
            INCLUDE_OFFLINE=true
            shift
            ;;
        --verbose)
            VERBOSE=true
            shift
            ;;
        --help|-h)
            show_help
            exit 0
            ;;
        -*)
            log_error "Unknown option: $1"
            show_help >&2
            exit 3
            ;;
        *)
            if [[ -z "$COMMAND" ]]; then
                COMMAND="$1"
            else
                log_error "Multiple commands specified"
                exit 3
            fi
            shift
            ;;
    esac
done

if [[ -z "$COMMAND" ]]; then
    log_error "Command required"
    show_help >&2
    exit 3
fi

# Validate output format
case "$OUTPUT_FORMAT" in
    json|table|csv) ;;
    *)
        log_error "Invalid output format: $OUTPUT_FORMAT"
        exit 3
        ;;
esac

# Check dependencies
check_dependencies

# Create directories
mkdir -p "$PAI_CONFIG_DIR" "$ENERGY_DATA_DIR" "$DISCOVERY_DATA_DIR"

# Export variables
export VERBOSE

# Execute command
case "$COMMAND" in
    full-discovery)
        full_discovery "$OUTPUT_FORMAT" "$VERBOSE"
        ;;
    network-devices)
        discover_network_devices "$VERBOSE"
        ;;
    ha-power-devices)
        discover_ha_power_devices "$VERBOSE"
        ;;
    power-analysis)
        analyze_power_patterns "$POWER_THRESHOLD" "$VERBOSE"
        ;;
    generate-map)
        generate_energy_map "$OUTPUT_FORMAT" "$INCLUDE_OFFLINE" "$VERBOSE"
        ;;
    device-profiling|baseline-audit|export-data)
        log_warn "Command '$COMMAND' not yet implemented"
        log_info "Available: full-discovery, network-devices, ha-power-devices, power-analysis, generate-map"
        exit 1
        ;;
    *)
        log_error "Invalid command: $COMMAND"
        show_help >&2
        exit 3
        ;;
esac

exit 0
