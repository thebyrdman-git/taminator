#!/usr/bin/env python3

"""
TAM RFE Report Scheduler Daemon
Automatic execution of scheduled reports with Phase 3 features
"""

import os
import sys
import time
import yaml
import subprocess
import smtplib
import logging
from datetime import datetime
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from pathlib import Path
from croniter import croniter

# Add lib directory to path for Phase 3 modules
SCHEDULER_ROOT = Path(__file__).parent.parent
sys.path.insert(0, str(SCHEDULER_ROOT / "lib"))

try:
    from template_engine import (
        ReportTemplate, 
        WEEKLY_DIGEST_HTML, 
        EXECUTIVE_BRIEF_HTML,
        create_weekly_digest_context,
        create_executive_brief_context
    )
    from conditional_executor import ConditionalExecutor
    from slack_notifier import SlackNotifier, create_success_blocks, create_failure_blocks
    PHASE3_AVAILABLE = True
except ImportError:
    PHASE3_AVAILABLE = False
    logger = logging.getLogger(__name__)
    logger.warning("Phase 3 modules not available - advanced features disabled")

# Configuration
CONFIG_DIR = Path.home() / ".config" / "tam-rfe-scheduler"
SCHEDULES_FILE = CONFIG_DIR / "schedules.yaml"
LOG_DIR = CONFIG_DIR / "logs"
PID_FILE = CONFIG_DIR / "daemon.pid"

# SMTP Configuration (using host's Postfix)
SMTP_SERVER = "localhost"
SMTP_PORT = 25

# Logging setup
LOG_DIR.mkdir(parents=True, exist_ok=True)
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
    handlers=[
        logging.FileHandler(LOG_DIR / "daemon.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)


class SchedulerDaemon:
    def __init__(self):
        self.schedules = []
        self.running = True
        
    def load_schedules(self):
        """Load schedules from YAML config"""
        if not SCHEDULES_FILE.exists():
            logger.warning(f"Schedules file not found: {SCHEDULES_FILE}")
            return []
        
        try:
            with open(SCHEDULES_FILE, 'r') as f:
                config = yaml.safe_load(f)
                schedules = config.get('schedules', [])
                
                # Filter enabled schedules
                enabled = [s for s in schedules if s.get('enabled', True)]
                logger.info(f"Loaded {len(enabled)} enabled schedule(s)")
                return enabled
        except Exception as e:
            logger.error(f"Failed to load schedules: {e}")
            return []
    
    def should_run(self, schedule):
        """Check if schedule should run now"""
        frequency = schedule.get('frequency', '')
        last_run = schedule.get('last_run')
        
        if not frequency:
            return False
        
        try:
            # Parse cron expression
            cron = croniter(frequency, datetime.now())
            next_run = cron.get_prev(datetime)
            
            # Check if we should run (within last minute)
            now = datetime.now()
            time_diff = (now - next_run).total_seconds()
            
            # Run if within 60 seconds of scheduled time and not run recently
            if 0 <= time_diff < 60:
                if last_run:
                    last_run_time = datetime.fromisoformat(last_run)
                    since_last = (now - last_run_time).total_seconds()
                    # Don't run if ran in last 60 seconds
                    if since_last < 60:
                        return False
                return True
            return False
        except Exception as e:
            logger.error(f"Error checking schedule {schedule.get('id')}: {e}")
            return False
    
    def execute_command(self, schedule):
        """Execute scheduled command with Phase 3 features"""
        schedule_id = schedule.get('id', 'unknown')
        schedule_name = schedule.get('name', schedule_id)
        command = schedule.get('command', '')
        
        logger.info(f"Executing schedule: {schedule_id}")
        
        # Phase 3: Check condition before execution
        if PHASE3_AVAILABLE:
            condition = schedule.get('condition')
            if condition and condition != 'always':
                should_run, reason = ConditionalExecutor.should_execute(schedule)
                logger.info(f"Condition check: {reason}")
                if not should_run:
                    logger.info(f"‚è≠Ô∏è  Skipping execution - condition not met")
                    return True  # Not a failure, just skipped
        
        logger.info(f"Command: {command}")
        
        try:
            # Execute command
            start_time = time.time()
            result = subprocess.run(
                command,
                shell=True,
                capture_output=True,
                text=True,
                timeout=300,  # 5 minute timeout
                cwd=str(Path.home())
            )
            duration = time.time() - start_time
            output = result.stdout if result.returncode == 0 else (result.stderr or result.stdout)
            
            # Log execution
            log_entry = {
                'schedule_id': schedule_id,
                'timestamp': datetime.now().isoformat(),
                'duration': duration,
                'exit_code': result.returncode,
                'success': result.returncode == 0
            }
            self.log_execution(log_entry)
            
            # Phase 3: Render template if specified
            template_name = schedule.get('template', 'plain')
            if PHASE3_AVAILABLE and template_name != 'plain':
                output = self.render_template(template_name, output, schedule)
            
            # Send notifications
            success = result.returncode == 0
            if success:
                logger.info(f"‚úÖ Command completed successfully ({duration:.1f}s)")
            else:
                logger.error(f"‚ùå Command failed with exit code {result.returncode}")
            
            # Email notification
            self.send_email(schedule, output, success=success, duration=duration)
            
            # Phase 3: Slack notification
            if PHASE3_AVAILABLE:
                slack_webhook = schedule.get('slack_webhook')
                if slack_webhook:
                    self.send_slack_notification(schedule, output, success, duration)
            
            # Update last_run in config
            self.update_last_run(schedule_id)
            
            return success
            
        except subprocess.TimeoutExpired:
            logger.error(f"‚è±Ô∏è  Command timed out after 5 minutes")
            error_msg = "Command execution timed out (>5 minutes)"
            self.send_email(schedule, error_msg, success=False, duration=300)
            if PHASE3_AVAILABLE and schedule.get('slack_webhook'):
                self.send_slack_notification(schedule, error_msg, False, 300)
            return False
        except Exception as e:
            logger.error(f"‚ùå Execution failed: {e}")
            error_msg = f"Execution error: {e}"
            self.send_email(schedule, error_msg, success=False, duration=0)
            if PHASE3_AVAILABLE and schedule.get('slack_webhook'):
                self.send_slack_notification(schedule, error_msg, False, 0)
            return False
    
    def render_template(self, template_name: str, output: str, schedule: dict) -> str:
        """Render output using specified template"""
        try:
            if template_name == 'weekly_digest':
                context = create_weekly_digest_context(output)
                template = ReportTemplate(template_string=WEEKLY_DIGEST_HTML)
                return template.render(context)
            elif template_name == 'executive_brief':
                context = create_executive_brief_context(output)
                template = ReportTemplate(template_string=EXECUTIVE_BRIEF_HTML)
                return template.render(context)
            else:
                # Custom template from file
                if template_name.startswith('custom:'):
                    template_path = template_name.split(':', 1)[1]
                    template = ReportTemplate(template_path=template_path)
                    context = {'output': output, 'schedule_name': schedule.get('name')}
                    return template.render(context)
            return output
        except Exception as e:
            logger.error(f"Template rendering failed: {e}")
            return output  # Fallback to plain output
    
    def send_slack_notification(self, schedule: dict, output: str, success: bool, duration: float):
        """Send notification to Slack"""
        webhook_url = schedule.get('slack_webhook')
        if not webhook_url:
            return
        
        try:
            notifier = SlackNotifier(webhook_url)
            schedule_name = schedule.get('name', schedule.get('id'))
            status = "success" if success else "failed"
            
            sent = notifier.send_message(
                title=schedule_name,
                output=output,
                status=status,
                duration=duration,
                schedule_name=schedule_name
            )
            
            if sent:
                logger.info(f"üì± Slack notification sent")
            else:
                logger.warning(f"‚ö†Ô∏è  Slack notification failed to send")
        except Exception as e:
            logger.error(f"‚ùå Slack notification error: {e}")
    
    def send_email(self, schedule, output, success=True, duration=0):
        """Send email notification"""
        email_to = schedule.get('email')
        schedule_name = schedule.get('name', schedule.get('id'))
        
        if not email_to:
            logger.warning("No email address configured for schedule")
            return
        
        try:
            # Create message
            msg = MIMEMultipart('alternative')
            msg['From'] = os.environ.get('USER', 'tam-scheduler') + '@' + os.uname().nodename
            msg['To'] = email_to
            
            if success:
                msg['Subject'] = f"‚úÖ {schedule_name} - Success"
                status_emoji = "‚úÖ"
                status_text = "Success"
            else:
                msg['Subject'] = f"‚ùå {schedule_name} - Failed"
                status_emoji = "‚ùå"
                status_text = "Failed"
            
            # Plain text version
            text = f"""
TAM RFE Report Scheduler
========================

Schedule: {schedule_name}
Status: {status_emoji} {status_text}
Duration: {duration:.1f}s
Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

Output:
-------
{output}

---
Automated by TAM RFE Scheduler
"""
            
            # HTML version
            html = f"""
<html>
<head>
<style>
body {{ font-family: 'Segoe UI', Arial, sans-serif; margin: 20px; }}
.header {{ background-color: {'#d4edda' if success else '#f8d7da'}; padding: 15px; border-radius: 5px; }}
.info {{ margin: 20px 0; }}
.output {{ background-color: #f8f9fa; padding: 15px; border-left: 4px solid {'#28a745' if success else '#dc3545'}; font-family: monospace; white-space: pre-wrap; }}
.footer {{ margin-top: 20px; color: #6c757d; font-size: 0.9em; }}
</style>
</head>
<body>
<div class="header">
<h2>{status_emoji} {schedule_name}</h2>
<p><strong>Status:</strong> {status_text}</p>
</div>

<div class="info">
<p><strong>Duration:</strong> {duration:.1f}s</p>
<p><strong>Timestamp:</strong> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
</div>

<div class="output">
<h3>Output:</h3>
<pre>{output}</pre>
</div>

<div class="footer">
<p>Automated by TAM RFE Report Scheduler</p>
</div>
</body>
</html>
"""
            
            # Attach both versions
            part1 = MIMEText(text, 'plain')
            part2 = MIMEText(html, 'html')
            msg.attach(part1)
            msg.attach(part2)
            
            # Send email
            with smtplib.SMTP(SMTP_SERVER, SMTP_PORT) as server:
                server.send_message(msg)
            
            logger.info(f"üìß Email sent to {email_to}")
            
        except Exception as e:
            logger.error(f"‚ùå Failed to send email: {e}")
    
    def log_execution(self, log_entry):
        """Log execution to history file"""
        log_file = LOG_DIR / "execution_history.jsonl"
        
        try:
            import json
            with open(log_file, 'a') as f:
                f.write(json.dumps(log_entry) + '\n')
        except Exception as e:
            logger.error(f"Failed to log execution: {e}")
    
    def update_last_run(self, schedule_id):
        """Update last_run timestamp in config"""
        try:
            with open(SCHEDULES_FILE, 'r') as f:
                config = yaml.safe_load(f)
            
            schedules = config.get('schedules', [])
            for schedule in schedules:
                if schedule.get('id') == schedule_id:
                    schedule['last_run'] = datetime.now().isoformat()
            
            with open(SCHEDULES_FILE, 'w') as f:
                yaml.dump(config, f, default_flow_style=False)
                
        except Exception as e:
            logger.error(f"Failed to update last_run: {e}")
    
    def write_pid(self):
        """Write PID file"""
        try:
            with open(PID_FILE, 'w') as f:
                f.write(str(os.getpid()))
            logger.info(f"PID file created: {PID_FILE}")
        except Exception as e:
            logger.error(f"Failed to write PID file: {e}")
    
    def remove_pid(self):
        """Remove PID file"""
        try:
            if PID_FILE.exists():
                PID_FILE.unlink()
                logger.info("PID file removed")
        except Exception as e:
            logger.error(f"Failed to remove PID file: {e}")
    
    def run(self):
        """Main daemon loop"""
        logger.info("=" * 60)
        logger.info("TAM RFE Report Scheduler Daemon Starting")
        logger.info("=" * 60)
        
        self.write_pid()
        
        try:
            while self.running:
                # Reload schedules every iteration (allows dynamic updates)
                self.schedules = self.load_schedules()
                
                # Check each schedule
                for schedule in self.schedules:
                    if self.should_run(schedule):
                        self.execute_command(schedule)
                
                # Sleep for 30 seconds before next check
                time.sleep(30)
                
        except KeyboardInterrupt:
            logger.info("Received interrupt signal")
        finally:
            self.remove_pid()
            logger.info("Daemon stopped")


def check_dependencies():
    """Check if required dependencies are available"""
    try:
        import croniter
        import yaml
        return True
    except ImportError as e:
        print(f"‚ùå Missing dependency: {e}")
        print("")
        print("Install with:")
        print("  pip install croniter pyyaml")
        return False


def main():
    if not check_dependencies():
        sys.exit(1)
    
    # Check if already running
    if PID_FILE.exists():
        try:
            with open(PID_FILE, 'r') as f:
                pid = int(f.read().strip())
            # Check if process is actually running
            os.kill(pid, 0)
            print(f"‚ùå Daemon already running (PID: {pid})")
            print(f"Stop it with: kill {pid}")
            sys.exit(1)
        except (OSError, ProcessLookupError):
            # Process not running, remove stale PID file
            PID_FILE.unlink()
    
    daemon = SchedulerDaemon()
    daemon.run()


if __name__ == '__main__':
    main()

